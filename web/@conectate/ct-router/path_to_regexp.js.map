{"version":3,"file":"path_to_regexp.js","sourceRoot":"","sources":["src/path_to_regexp.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Match matching groups in a regular expression.\n */\nvar MATCHING_GROUP_REGEXP = /\\((?!\\?)/g;\n\ninterface OptionsType {\n\tsensitive?: boolean,\n\tstrict?: boolean,\n\tend?: boolean,\n\tstart?: boolean,\n\tdelimiter?: boolean,\n\tendsWith?: string,\n\twhitelist?: any[]\n}\n\nexport interface C2RegexpType {\n\tregexp: RegExp,\n\tgroups: string[]\n}\n\n/**\n * Normalize the given path string,\n * returning a regular expression.\n *\n * An empty array should be passed,\n * which will contain the placeholder\n * key names. For example \"/user/:id\" will\n * then contain [\"id\"].\n *\n * @param  {String|RegExp|Array} path\n * @param  {Array} keys\n * @param  {OptionsType} options\n * @return {RegExp}\n * @api private\n */\nexport function pathtoRegexp(path: string | RegExp | Array<any>, keys: Array<any>, options: OptionsType): RegExp {\n\toptions = options || {};\n\tkeys = keys || [];\n\tvar strict = options.strict;\n\tvar end = options.end !== false;\n\tvar flags = options.sensitive ? '' : 'i';\n\tvar extraOffset = 0;\n\tvar keysOffset = keys.length;\n\tvar i = 0;\n\tvar name = 0;\n\tvar m;\n\n\tif (path instanceof RegExp) {\n\t\twhile (m = MATCHING_GROUP_REGEXP.exec(path.source)) {\n\t\t\tkeys.push({\n\t\t\t\tname: name++,\n\t\t\t\toptional: false,\n\t\t\t\toffset: m.index\n\t\t\t});\n\t\t}\n\n\t\treturn path;\n\t}\n\n\tif (Array.isArray(path)) {\n\t\t// Map array parts into regexps and return their source. We also pass\n\t\t// the same keys and options instance into every generation to get\n\t\t// consistent matching groups before we join the sources together.\n\t\tpath = path.map(function (value) {\n\t\t\treturn pathtoRegexp(value, keys, options).source;\n\t\t});\n\n\t\treturn new RegExp('(?:' + path.join('|') + ')', flags);\n\t}\n\n\tpath = ('^' + path + (strict ? '' : path[path.length - 1] === '/' ? '?' : '/?'))\n\t\t.replace(/\\/\\(/g, '/(?:')\n\t\t.replace(/([\\/\\.])/g, '\\\\$1')\n\t\t.replace(/(\\\\\\/)?(\\\\\\.)?:(\\w+)(\\(.*?\\))?(\\*)?(\\?)?/g, function (match, slash, format, key, capture, star, optional, offset) {\n\t\t\tslash = slash || '';\n\t\t\tformat = format || '';\n\t\t\tcapture = capture || '([^\\\\/' + format + ']+?)';\n\t\t\toptional = optional || '';\n\n\t\t\tkeys.push({\n\t\t\t\tname: key,\n\t\t\t\toptional: !!optional,\n\t\t\t\toffset: offset + extraOffset\n\t\t\t});\n\n\t\t\tvar result = ''\n\t\t\t\t+ (optional ? '' : slash)\n\t\t\t\t+ '(?:'\n\t\t\t\t+ format + (optional ? slash : '') + capture\n\t\t\t\t+ (star ? '((?:[\\\\/' + format + '].+?)?)' : '')\n\t\t\t\t+ ')'\n\t\t\t\t+ optional;\n\n\t\t\textraOffset += result.length - match.length;\n\n\t\t\treturn result;\n\t\t})\n\t\t.replace(/\\*/g, function (_star, index) {\n\t\t\tvar len = keys.length\n\n\t\t\twhile (len-- > keysOffset && keys[len].offset > index) {\n\t\t\t\tkeys[len].offset += 3; // Replacement length minus asterisk length.\n\t\t\t}\n\n\t\t\treturn '(.*)';\n\t\t});\n\n\t// This is a workaround for handling unnamed matching groups.\n\twhile (m = MATCHING_GROUP_REGEXP.exec(path)) {\n\t\tvar escapeCount = 0;\n\t\tvar index = m.index;\n\n\t\twhile (path.charAt(--index) === '\\\\') {\n\t\t\tescapeCount++;\n\t\t}\n\n\t\t// It's possible to escape the bracket.\n\t\tif (escapeCount % 2 === 1) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (keysOffset + i === keys.length || keys[keysOffset + i].offset > m.index) {\n\t\t\tkeys.splice(keysOffset + i, 0, {\n\t\t\t\tname: name++, // Unnamed matching groups must be consistently linear.\n\t\t\t\toptional: false,\n\t\t\t\toffset: m.index\n\t\t\t});\n\t\t}\n\n\t\ti++;\n\t}\n\n\t// If the path is non-ending, match until the end or a slash.\n\tpath += (end ? '$' : (path[path.length - 1] === '/' ? '' : '(?=\\\\/|$)'));\n\t\n\treturn new RegExp(path, flags);\n};\n\n/**\n * https://www.npmjs.com/package/path-to-regexp\n * let c2 = C2Regexp(\"/:username/job/:name--:jid(\\\\d+)\");\n * let c3 = C2Evaluate(\"/conectate/job/nameee--123\", c2);\n */\nvar opts = {\n\tstrict: false,\n\tsensitive: false,\n\tend: true\n}\n\nexport function EvaluateParams(path: string, c2regexp: C2RegexpType) {\n\tlet r = path.match(c2regexp.regexp);\n\tif (r != null) {\n\t\tlet result: any = {};\n\t\tfor (let i = 0; i < c2regexp.groups.length; i++) {\n\t\t\tresult[c2regexp.groups[i]] = r[i + 1];\n\t\t}\n\t\treturn result; // {username : \"herberth\",\"jid\" : 1234}\n\t}\n}\n\nexport function C2Regexp(path: string) : C2RegexpType {\n\ttry {\n\t\tlet keys: any[] = [], finalKeys: string[] = [];\n\t\tlet r = pathtoRegexp(path, keys, opts);\n\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\tfinalKeys.push(keys[i].name);\n\t\t}\n\t\treturn {\n\t\t\tregexp: r,\n\t\t\tgroups: finalKeys\n\t\t}\n\t} catch (e) {\n\t\tconsole.error(e,'Error al generar', path)\n\t\treturn {\n\t\t\tregexp: /^\\/?$/i,\n\t\t\tgroups: []\n\t\t};\n\t}\n}"]}